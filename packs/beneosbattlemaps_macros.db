{"name":"Beneos Battlemaps: Migrate all scenes in your world to the new file system (v.1.4.0 to v.2.0.0)","type":"script","author":"vq0NGLlwRM2vTPNW","img":"icons/svg/book.svg","scope":"global","command":"// Migrate Beneosbattlemaps asset locations to the new format.\n(async () => {\n    if (!game.user.isGM) {\n      return;\n    }\n  \n    const gameVersion = game.version || game.data.version;\n    if (isNewerVersion('0.8.6', gameVersion)) {\n      Dialog.prompt({\n        title: 'Beneosbattlemaps Asset Location Migrator',\n        content: '<p>This process is only available for Foundry VTT versions 0.8.6 and above.</p>',\n        label: 'Close',\n        callback: () => {\n        },\n      });\n      return;\n    }\n  \n    Dialog.confirm({\n      title: 'Beneosbattlemaps Asset Location Migrator',\n      content: '<p>This macro will change your scenes in your world from the old data structure to the new data structure.' +\n        ' This means that you do not need to reimport your prepared scenes.</p>' +\n        '<p><em>You only need to do this once.</em></p>' +\n        '<p>It is strongly recommended to make a <a href=\"https://foundryvtt.com/article/configuration/#backup\" target=\"_blank\">backup of your world folder</a> prior to running this process.</p>' +\n        '<hr><form autocomplete=\"off\"><div class=\"form-group\"><label for=\"dry-run\">Save changes?</label><input id=\"dry-run\" type=\"checkbox\"></div>' +\n        '<p class=\"notes\">Leaving this unchecked will operate in a \"dry run\" mode, where changes are only output to the console (F12).</p></form><hr>',\n      yes: async (html) => {\n        const dryRun = !html.find('input[type=\"checkbox\"]')[0].checked;\n        const moduleVersion = game.modules.get('beneosbattlemaps')?.data?.version || '0.0.0';\n        if (!isNewerVersion(moduleVersion, '1.9.9')) {\n          Dialog.prompt({\n            title: 'Beneosbattlemaps Asset Location Migrator',\n            content: '<p>This process is only available for Beneosbattlemaps versions 2.0.0 and above.</p>',\n            label: 'Close',\n            callback: () => {\n            },\n          });\n          return;\n        }\n        console.group('Beneosbattlemaps Asset Migrator process started:');\n        if (dryRun) {\n          console.log('Dry run mode enabled. No changes will be made.');\n        }\n        await process(dryRun, 'Actors', [{path: 'migrate_old_npcs.db.json'}]);\n        await process(dryRun, 'Journals', [{path: 'migrate_old_journal.db.json'}]);\n        await process(dryRun, 'Scenes', [\n          {path: 'migrate_old_bat_4k.db.json', type: '4K'},\n          {path: 'migrate_old_bat_hd.db.json', type: 'HD'},\n          {path: 'migrate_old_scen_4k.db.json', type: '4K'},\n          {path: 'migrate_old_scen_hd.db.json', type: 'HD'},\n        ]);\n        console.groupEnd();\n      },\n      no: () => console.log('Cancelled Beneosbattlemaps Asset Migrator.'),\n    });\n  \n    async function process(dryRun, type, files) {\n      const domParser = new DOMParser();\n      const displayProgressBar = SceneNavigation.displayProgressBar || SceneNavigation._onLoadProgress;\n      try {\n        console.log(`Processing ${type}...`);\n        let gameType;\n        switch (type) {\n          case 'Actors':\n            gameType = Actor;\n            break;\n          case 'Journals':\n            gameType = JournalEntry;\n            break;\n          case 'Scenes':\n            gameType = Scene;\n            break;\n        }\n        const collection = game[gameType.collectionName];\n        const updates = [];\n        for (const file of files) {\n          const resp = await fetch(`modules/beneosbattlemaps/packs/migration/${file.path}`, window.location);\n          const mappingData = await resp.json();\n          if (!mappingData.count) {\n            continue;\n          }\n          let idx = 0;\n          for (const [sourceId, pathLocations] of Object.entries(mappingData.data)) {\n            // Find the documents that match the sourceId and the correct HD/4K value\n            const matchingDocuments = collection.filter(d => {\n              const hasCorrectSource = d.getFlag('scene-packer', 'sourceId') === sourceId || d.getFlag('core', 'sourceId') === sourceId;\n              const hasCorrectFileType = !file.type || (d.img?.split('/')?.pop() || '').startsWith(file.type);\n              return hasCorrectSource && hasCorrectFileType;\n            });\n            for (const matchingDocument of matchingDocuments) {\n              // Replaced tracks which assets have been replaced already due to some being done in bulk\n              const replaced = {};\n              for (const [path, locations] of Object.entries(pathLocations)) {\n                for (const location of locations) {\n                  if (location.source === location.destination) {\n                    continue;\n                  }\n  \n                  let update = {\n                    _id: matchingDocument.id,\n                  };\n                  let changed = false;\n                  const currentValue = getProperty(matchingDocument.data, path);\n  \n                  if (path === 'img') {\n                    if (currentValue === location.source) {\n                      console.debug(`Replacing ${matchingDocument.id} ${matchingDocument.name} ${path} ${location.source} => ${location.destination}`, {\n                        path,\n                        doc: matchingDocument.data,\n                        currentValue,\n                        location,\n                      });\n                      update[path] = location.destination;\n                      updates.push(update);\n                      changed = true;\n                    }\n                  } else if (path === 'content') {\n                    const doc = domParser.parseFromString(currentValue, 'text/html');\n                    for (const image of doc.getElementsByTagName('img')) {\n                      if (image.src === location.source || new URL(location.source, window.location).href) {\n                        image.src = location.destination;\n                        changed = true;\n                      }\n                    }\n                    if (changed) {\n                      console.debug(`Replacing ${matchingDocument.id} ${matchingDocument.name} ${path} ${location.source} => ${location.destination}`, {\n                        path,\n                        doc: matchingDocument.data,\n                        currentValue,\n                        location,\n                      });\n                      update['content'] = doc.body.innerHTML;\n                      updates.push(update);\n                    }\n                  } else if (path.startsWith('sounds')) {\n                    // Embedded sounds in scenes\n                    const scene = collection.get(matchingDocument.id);\n                    if (scene) {\n                      const soundUpdates = scene.sounds.filter(s => s.data.path === location.source).map(s => {\n                        return {\n                          _id: s.id,\n                          path: location.destination,\n                        };\n                      });\n                      if (soundUpdates.length) {\n                        console.debug(`Replacing ${matchingDocument.id} ${matchingDocument.name} ${path} ${location.source} => ${location.destination}`, {\n                          path,\n                          doc: matchingDocument.data,\n                          currentValue,\n                          location,\n                        });\n                        changed = true;\n                        replaced[location.source] = location.destination;\n                        if (!dryRun) {\n                          await scene.updateEmbeddedDocuments('AmbientSound', soundUpdates);\n                        }\n                      }\n                      // Check if this has been replaced already\n                      if (!changed && replaced[location.source] === location.destination) {\n                        console.warn(`Already replaced ${matchingDocument.id} ${matchingDocument.name} ${path} ${location.source} => ${location.destination}`);\n                        changed = true;\n                      }\n                    }\n                  } else if (path.startsWith('tiles')) {\n                    // Embedded tiles in scenes\n                    const scene = collection.get(matchingDocument.id);\n                    if (scene) {\n                      const tileUpdates = scene.tiles.filter(t => t.data.img === location.source).map(t => {\n                        return {\n                          _id: t.id,\n                          img: location.destination,\n                        };\n                      });\n                      if (tileUpdates.length) {\n                        console.debug(`Replacing ${matchingDocument.id} ${matchingDocument.name} ${path} ${location.source} => ${location.destination}`, {\n                          path,\n                          doc: matchingDocument.data,\n                          currentValue,\n                          location,\n                        });\n                        changed = true;\n                        replaced[location.source] = location.destination;\n                        if (!dryRun) {\n                          await scene.updateEmbeddedDocuments('Tile', tileUpdates);\n                        }\n                      }\n                      // Check if this has been replaced already\n                      if (!changed && replaced[location.source] === location.destination) {\n                        changed = true;\n                      }\n                    }\n                  } else if (path.startsWith('tokens') && type === 'Scenes') {\n                    if (!path.endsWith('img')) {\n                      console.error(`Unhandled scene->token path ${path}`);\n                    }\n                    // Embedded tokens in scenes\n                    const scene = collection.get(matchingDocument.id);\n                    if (scene) {\n                      const tokenUpdates = scene.tokens.filter(t => t.data.img === location.source).map(t => {\n                        return {\n                          _id: t.id,\n                          img: location.destination,\n                        };\n                      });\n                      if (tokenUpdates.length) {\n                        console.debug(`Replacing ${matchingDocument.id} ${matchingDocument.name} ${path} ${matchingDocument.data[path]} => ${location.destination}`, {\n                          path,\n                          doc: matchingDocument.data,\n                          currentValue,\n                          location,\n                        });\n                        changed = true;\n                        if (!dryRun) {\n                          await scene.updateEmbeddedDocuments('Token', tokenUpdates);\n                        }\n                      }\n                    }\n                  } else {\n                    console.error(`Unhandled path ${path} ${type} ${matchingDocument.id} ${matchingDocument.name} ${matchingDocument.data[path]} !== ${location.source}`);\n                  }\n  \n                  if (!changed) {\n                    console.warn(`${type} ${matchingDocument.id} ${matchingDocument.name} ${path} ${matchingDocument.data[path]} !== ${location.source}`, {\n                      path,\n                      doc: matchingDocument.data,\n                      currentValue,\n                      location,\n                    });\n                  }\n                }\n              }\n            }\n            idx++;\n            const percent = Math.round((idx / mappingData.count) * 100);\n            displayProgressBar(`Migrating ${type} data from ${file.path}`, percent);\n          }\n        }\n        if (updates.length) {\n          console.log(`Updating ${updates.length} ${type}...`);\n          console.table(updates);\n          if (!dryRun) {\n            await gameType.updateDocuments(updates);\n          }\n        }\n        console.log(`Finished processing ${type}.`);\n      } catch (e) {\n        console.error(`Error processing ${type}:`);\n        console.error(e);\n      }\n    }\n  })();","folder":null,"sort":0,"permission":{"default":0,"vq0NGLlwRM2vTPNW":3},"flags":{"core":{"sourceId":"Macro.Mf90xXRqXtcrDTJ4"},"scene-packer":{"sourceId":"Macro.Mf90xXRqXtcrDTJ4"}},"_id":"7MkQOEJSx6gbkoX9"}
{"name":"Unpack all Scenes in your world at once","type":"script","author":"vq0NGLlwRM2vTPNW","img":"icons/svg/door-exit.svg","scope":"global","command":"// This macro will unpack any scenes in your world that have\n// packed data. It can be used to prevent you needing to go\n// through activating each scene one by one.\n(async () => {\n  ScenePacker.PromptForInstance().then(async instance => {\n    if (!instance?.moduleName) {\n      return;\n    }\n\n    const scenes = [];\n    for (const scene of game.scenes) {\n      if (ScenePacker.HasPackedData(scene, instance.moduleName)) {\n        scenes.push(scene);\n      }\n    }\n    if (!scenes.length) {\n      return ui.notifications.info(`There are no scenes that need unpacking in \"${instance.moduleName}\".`);\n    }\n\n    ui.notifications.info(`Unpacking ${scenes.length} scenes in \"${instance.moduleName}\".`);\n    console.log(`Unpacking ${scenes.length} scenes in \"${instance.moduleName}\".`);\n    for (const scene of scenes) {\n      await instance.ProcessScene(scene, {showLinkedJournal: false, showUI: false});\n    }\n    ui.notifications.info(`Done. Unpacked ${scenes.length} scenes in \"${instance.moduleName}\".`);\n    console.log(`Done. Unpacked ${scenes.length} scenes in \"${instance.moduleName}\".`);\n  })\n})();","folder":null,"sort":0,"permission":{"default":0,"vq0NGLlwRM2vTPNW":3},"flags":{"core":{"sourceId":"Macro.etwWCTplq9zqu0Ee"},"scene-packer":{"sourceId":"Macro.etwWCTplq9zqu0Ee"}},"_id":"T1G0E6jL6w8jUz9Z"}
